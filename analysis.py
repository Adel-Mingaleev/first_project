# Вступление:

# Для удобства приведу общую информацию о файле и моей работе.

# На листе "Массив" приведен список слушателей курсов повышения квалификации.
# На листе "Отрасли-Направления" указано направление для каждой отрасли.
# Лист "Модераторы" содержит ФИО модераторов и предпочтительные отрасли для каждого модератора.


# Содержание работы:

# 1. Проверка данных на корректность (дубликаты, посторонние символы, выбросы).
# 2. Анализ половозрастного состава слушателей.
# 3. Для каждого слушателя определяем направление (ООЦ/ЕМЦ).
# 4. Назначаем каждому слушателю модератора.



# Импортируем библиотеку Pandas:

import pandas as pd


# Формируем датафреймы из файла "Project.xlsx":
df_main = pd.read_excel(r'C:\Downloads\Project.xlsx', sheet_name = 'Массив')
df_areas = pd.read_excel(r'C:\Downloads\Project.xlsx', sheet_name = 'Отрасли-Направления')
df_mods = pd.read_excel(r'C:\Downloads\Project.xlsx', sheet_name = 'Модераторы')



# 1. Проверка данных на корректность.



# Выведем общую информацию о таблице:
print(df_main.info())
# К типам данных вопросов нет, баллы в виде десятичных чисел, даты рождения в datetime, остальные столбцы - текст.



# Проверка на дубликаты:
print(df_main[df_main.duplicated(['Фамилия', 'Имя', 'Отчество', 'Дата рождения'], keep=False)])
# Есть полностью одинаковые строки, а также есть строки, в которых во втором вхождении 0 баллов за тест. Удалим данные строки:
df_main = df_main.drop_duplicates(['Фамилия', 'Имя', 'Отчество', 'Дата рождения'], keep='first')



# Проверка на пропуски:
print(df_main[df_main.isnull().any(axis=1)])
# Строки с пропусками в столбцах "Отчество", "Дата рождения", "Роль", "Образовательная организация" я оставлю, так как они не помешают дальнейшей работе.
# А строки с пропусками в столбце "Укрупненные группы направлений подготовки/ФГОС 3++/Отрасль" придется удалить, так как
# для данных слушателей мы не сможем определить направление и назначить модератора.
df_main.dropna(subset=['Укрупненные группы направлений подготовки/ФГОС 3++/Отрасль'], inplace=True)
print(df_main[df_main.isnull().any(axis=1)])



# Обработка столбца "Фамилия".

# Проверим, что все символы - буквенные:
print(df_main[df_main['Фамилия'].str.isalpha() == False])
# Дефисы в фамилиях уместны.

# Проверим наличие латинских букв:
print(df_main[df_main['Фамилия'].str.match(r'.*[a-zA-Z]')])
# Латинских букв в фамилиях нет.

# Проверим, начинаются ли фамилии с прописной буквы (имеют ли все строки "титульное" значение):
print(df_main[~df_main['Фамилия'].str.istitle()])
# Написание фамилий в виде "Маадыр-оол" не является ошибкой.



# Обработка столбца "Имя".

# Проверим, что все символы - буквенные:
print(df_main[df_main['Имя'].str.isalpha() == False])
# Имя "Уго рикардо" записано через пробел. Будем считать, что каждая часть имени должна начинаться с прописной буквы. Исправим это значение:
df_main.loc[df_main['Имя'].str.isalpha() == False, 'Имя'] = df_main.loc[df_main['Имя'].str.isalpha() == False, 'Имя'].str.title()

# Проверим на наличие латинских букв:
print(df_main[df_main['Имя'].str.match(r'.*[a-zA-Z]')])
# Латинских букв нет.

# Проверим, начинаются ли имена с прописной буквы:
print(df_main[~df_main['Имя'].str.istitle()])
# Все хорошо, переходим к следующему столбцу.



# Обработка столбца "Отчество".

# Проверим, что все символы - буквенные:
print(df_main[df_main['Отчество'].str.isalpha() == False])
# Мы видим, что в некоторых строках в конце стоит символ переноса строки и лишние пробелы. Уберем их:
df_main['Отчество'] = df_main['Отчество'].str.strip('\n ')
# Проверим, что все изменения прошли успешно:
print(df_main[df_main['Отчество'].str.isalpha() == False])

# Проверим на наличие латинских букв:
mask = df_main['Отчество'][df_main['Отчество'].notnull()]
print(mask[mask.str.match(r'.*[a-zA-Z]')])
# В данной строке в отчестве имеется латинская буква "C". Произведём замену:
df_main.loc[df_main['Отчество']=='Cерафимовна', 'Отчество'] = 'Серафимовна'

# Проверим, что все отчества начинаются с прописной буквы:
print(mask[~mask.str.istitle()])
# Написание отчества в виде "Ахмад оглы" или "Мунир кызы" не является ошибкой.



# Столбец "Дата рождения" пока оставим, вернемся к нему, когда будем работать с возрастом.



# Обработка столбца "Роль".

# Выведем уникальные значения, их должно быть всего два:
print(df_main['Роль'].unique())
# Все хорошо, пропуски не помешают дальнейшей работе.



# Обработка столбца "Образовательная организация".

# В некоторых строках встречается неправильное отображение кавычек '&quot;'. Заменим их на стандартный знак:
df_main['Образовательная организация'] = df_main['Образовательная организация'].str.replace('&quot;', '"')



# Обработка столбца "Укрупненные группы направлений подготовки/ФГОС 3++/Отрасль".

# Вынесем отрасль слушателя в отдельный столбец, так как это понадобится нам в дальнейшем:
df_main.insert(7, 'Отрасль', df_main.iloc[:, 6] \
                                            .map(lambda x: x.split(' / ')[2].split(':')[0].strip()))
# Проверим на наличие латинских символов:
print(df_main[df_main['Отрасль'].str.match(r'.*[a-zA-Z]')])
# Латинских символов нет.



# Обработка столбца "Балл за тест".

# Проверим на наличие выбросов:
print(df_main[df_main['Балл за тест'] < 0])
print(df_main[df_main['Балл за тест'] > 1])
# Все хорошо, все значения в диапазоне от 0 до 1.



# Обработка листа "Отрасли-направления".

print(df_areas['Отрасль'].unique())
# Все значения в столбце 'Отрасль' уникальны, ошибок нет.
print(df_areas[df_areas['Отрасль'].str.match(r'.*[a-zA-Z]')])
# Латинских букв нет.
print(df_areas['Направление'].unique())
# Как и ожидалось, получаем только два значения. Все хорошо, переходим к следующему листу.



# Обработка листа "Модераторы".

print(df_mods[df_mods['ФИО'].str.match(r'.*[a-zA-Z]')])
print(df_mods[df_mods['Предпочтительная отрасль'].str.match(r'.*[a-zA-Z]')])
# Здесь тоже все в порядке.



# 2. Анализ половозрастного состава слушателей.



# Определим пол слушателей по отчеству. Для этого создадим столбец "Пол", куда скопируем отчество слушателей.
df_main.insert(3, 'Пол', df_main['Отчество'])
df_main['Пол'] = df_main['Пол'][df_main['Пол'].notnull()] \
                                                        .map(lambda x: 'муж' if x.endswith('ич') else x)
df_main['Пол'] = df_main['Пол'][df_main['Пол'].notnull()] \
                                                        .map(lambda x: 'жен' if x.endswith('на') else x)

# Но отчество не всегда оканчивается на "ич" и "на", проверим оставшиеся значения:
patronymic = df_main[df_main['Пол'] != 'муж']
print(patronymic[patronymic['Пол'] != 'жен'])

# Напишем скрипт для окончаний "оглы" и "кызы":
df_main['Пол'] = df_main['Пол'][df_main['Пол'].notnull()] \
                                                        .map(lambda x: 'муж' if x.endswith('оглы') else x)
df_main['Пол'] = df_main['Пол'][df_main['Пол'].notnull()] \
                                                        .map(lambda x: 'жен' if x.endswith('кызы') else x)

# Для слушателей, у которых не указано отчество, определим пол по окончанию фамилии:
df_main.loc[df_main['Пол'].isnull(), 'Пол'] = df_main.loc[df_main['Пол'].isnull(), 'Фамилия'] \
                                                        .map(lambda x: 'жен' if x.endswith('ва') else 'муж')

# Проверим данные еще раз:
print(df_main['Пол'].unique())
# Отлично, пол указан у всех слушателей.



# Определям возраст слушателей:
from datetime import datetime
# Задаем сегодняшнюю дату.
today = datetime.today()
# Вычитаем из сегодняшней даты день рождения слушателя.
df_main.insert(5, 'Возраст', df_main['Дата рождения'] \
                                            .apply(lambda x: today.year - x.year - ((today.month, today.day) < (x.month, x.day))))

# Проверим данные на наличие аномальных значений:
print(df_main.sort_values(by='Возраст').head())
print(df_main.sort_values(by='Возраст', ascending=False).head())
# Мы видим, что у некоторых слушателей указан возраст 1, 3, 122 года, чего быть не может. Подставим None вместо этих значений:
df_main.loc[df_main['Возраст'] > 90, 'Возраст'] = None
df_main.loc[df_main['Возраст'] < 18, 'Возраст'] = None



# Разобьем всех слушателей на категории по возрасту.
# При визуализации данных такой способ будет более наглядным.
bins = [18, 30, 40, 50, 60, 70, 100]
labels = ['18-29', '30-39','40-49','50-59','60-69', '70+']
df_main.insert(6, 'Возрастная группа', pd.cut(df_main['Возраст'], bins, labels=labels, right=False))



# Также изменим тип данных в столбце 'Дата рождения' с datetime на date_format, чтобы при выгрузке данных не отображалось время, а только дата.
df_main['Дата рождения'] = pd.to_datetime(df_main['Дата рождения'], format= '%Y-%m-%d').dt.date



# 3. Для каждого слушателя определяем направление (ООЦ/ЕМЦ).

# Так как в таблице "Массив" и в таблице "Отрасли-Направления" есть столбец "Отрасль" мы можем присоединить к таблице "Массив"
# столбец "Направление", используя столбец "Отрасль".
df_main = df_main.merge(df_areas, on=['Отрасль'], how='left')
# Таким образом мы определили направление для каждого слушателя в зависимости от отрасли.
# Столбец "Направление" подставим после столбца "Отрасль":
df_main = df_main[['Фамилия', 'Имя', 'Отчество', 'Пол', 'Дата рождения', 'Возраст', 'Возрастная группа', 'Роль',
                   'Образовательная организация','Укрупненные группы направлений подготовки/ФГОС 3++/Отрасль',
                   'Отрасль', 'Направление', 'Балл за тест',]]



# 4. Назначаем каждому слушателю модератора.

# Создадим словарь, где ключами будут отрасли, а значениями - модераторы, которые предпочитают данную отрасль:

# Создадим список из уникальных значений столбца "Отрасль"
areas_list = df_areas['Отрасль'].tolist()

dict_areas = {}
for i in areas_list:                                                # Запускаем цикл по отраслям
    for j in range(len(df_mods['Предпочтительная отрасль'])):       # Запускаем цикл по строкам таблицы "Модераторы"
        if i in df_mods['Предпочтительная отрасль'][j]:             # Если данная отрасль является предпочтительной для данного модератора, то
            if i in dict_areas:                                     # добавляем этого модератора как значение для данного ключа.
                dict_areas[i].append(df_mods['ФИО'][j])
            else:
                dict_areas[i] = [df_mods['ФИО'][j]]

# В основную таблицу добавим столбец "Модератор", куда определим модератора в зависимости от предпочтительной отрасли:
import random
df_main.insert(12, 'Модератор', df_main['Отрасль'].map(lambda x: random.choice(dict_areas[x])))
# Отлично, теперь каждому слушателю назначен модератор.



# Сохраним датафрейм df_main в формате xlsx для дальнейшего построения графиков в программе Power BI:
df_main.to_excel(r'C:\Downloads\df_main.xlsx', index=False, sheet_name='Массив')


